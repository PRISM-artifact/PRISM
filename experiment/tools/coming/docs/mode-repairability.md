#  ComRepair: Revision Classification 


We classify each revision into which program-repair-tool's search space it may lie. 
Our goal is to make a module in coming which takes a software repository or a list of revisions as an input 
and for each commits/revision it outputs a list of program repair tools. 
If commit `c` is classified as `x`, it means that `c` might have been produced by the program repair tool `x` 
or in order words `c` lies in the search space of `x` tool.

This module takes a list of revision as input and outputs produces a list of instances/diffs that could have been generated by one of the supported repair-tools. 

The flow of this module is as follows:

- Apply FineGrainDifftAnalyzer to input: This basically produces a list of fine-grained diffs/revisions in the input
- Use `fr.inria.coming.repairability.RepairTools` to get list of patterns to be mined as per repair-tools specified in `-repairtool`
- We use patterns we get from above and invoke `PatternInstanceAnalyzer`, 
which outputs a list of instances that match any one of the patterns given as input.
- The output of `PatternInstanceAnalyzer` is given `RepairabilityAnalyzer. It invokes filter(of the repair-tool, with whose pattern it was matched) on each instance found above
- The output of `RepairabilityAnalyzer` is given to  `JSONRepairabilityOutput`, which produces a json with a list of instances
    - each instance is a single revision
    - each revision has a list of repairability
    - each repairability represents a single repair tool that could have generated that revision
 
 
## How to add a new Repair Tool

- Create a new class, `x`, in the package `fr.inria.coming.repairability.repairtools`. `x` should extend `fr.inria.coming.repairability.repairtools.AbstractRepairTool`.
- Add the name of the class, `x`, to the array `supportedTools` in `fr.inria.coming.repairability.RepairTools`
- The new class should at least implement the method ` protected List<ChangePatternSpecification> readPatterns()`
- The class may override ` public boolean filter(ChangePatternInstance instance, IRevision revision);`

### readPatterns()

Each repair tool has a particular search space, i.e, the patches produced by it are supposed to have a certain kind of characteristics.
We believe that this search space can be specified by [Change Pattern Specification(or patterns)](https://github.com/SpoonLabs/coming#change-pattern-specification).
For example, if a commit only changes a binary operator, it is in the search space of jMutRepair and it can be represented by the following pattern:
```xml
<pattern name="binary">
	<entity id="1" type="BinaryOperator"/>
	<action entityId="1" type="UPD"/>
</pattern>
```
This xml pattern is abstracted as `ChangePatternSpecification` in Coming. 
This method is supposed to return all the patterns(that helps in specifying the search space of that tool) in form a list of ChangePatternSpecification.
One of the methods to do it is:
- add the required .xml files to a folder `/src/main/resources/repairability/<repair-tool-name>/`
- read those .xml file using `PatternXMLParser.parseFile(getPathFromResources(fileName))`, which returns a single ChangePatternSpecification corresponding to the xml.
- read all all the .xml for that repair tool and return a `List<ChangePatternSpecification>`.
 

The output of `readPatterns()` will be modified a little bit by `AbstractRepairTool.getPatterns()` and then given to `PatternInstanceAnalyser` to mine the required patterns.

### filter()
Certain characteristics/features of search space of a repair-tool can't be specified in the .xml or the Change Pattern Specification. 
There filter function is provided to specify extra constrains over the instances mined `PatternInstanceAnalyzer` 
using the patterns provided by `readPatterns()` of that repair-tool.
This means that we can allow patterns in readPatterns() to be lenient and apply stronger checks in filter to get the desired search space.
 `ChangePatternInstance` is a very information rich object that contains almost all the information about the AST nodes involved.

A `ChangePatternInstance` object is input to the `filter()`. The object represents a change instance in code that was matched with one of the patterns specific to that repair-tool.
If `filter()` returns false, the `ChangePatternInstance` is dropped. Otherwise it is passed to the output processor.  

We also pass the `IRevision` corresponding to the instance in the filter function. This can be used get the source code involving the revision
and therefore it can prove helpful in cases like JGenProg, where we want to check if the inserted/updated statement was present in the previous version of the file.
  
## Usage
Though you need to implement `readPatterns()`, one should only use `getPatterns()` while trying to use the repair tool module.
`RepairTools` class provides several features to use one or several repair-tools with ease.
 
Notes:

-  **One file modification per commit/IRevision**
    Each input(aka commit or IRevision) should have modification in only one file. 
    If a revision modifies more than one file then, it couldnt have be generated by a repair-tool.

- **<= 1 instance of each repair tool per commit/IRevision**
    Each commit(aka IRevision) should have not more than one instances of a particular repair tool.
    This is because the repair tools we are dealing make patches which affects just one file and each patch corresponds to a revision or commit.
   
    More discussion about the same can be found here: https://github.com/SpoonLabs/coming/issues/94
    one instancePerDiff represent one result/one revision and in one revision there should be at max of one instance of any repair-tool


## Program Repair Tools
A list of program repair tools we are going to handle:- 
 
 ### jMutRepair 
 
 Paper: [Using Mutation to Automatically Suggest Fixes for Faulty Programs ](http://www.utdallas.edu/~ewong/SE6367/01-Project/08-SFL-papers/10-Automatically-Suggest-Fixes.pdf)

 #### Research Summary
 The paper experiments with the following settings:
 - It *replaces* the following operators with an operator of *the same class*.
     - Arithmetic
     - Relational
     - Logical
     - Increment/Decrement
     - Assignment (TODO: What could be changed in this?)
 - Or it can do *negation* in an `if` or `while` statement.
 
 A mutant(the program after one repair operation/change) is killed if any test case fails. 
 This means that the patch generated can contain only one change.  
 
 ##### Real-world patches note
 But these settings can change, for example negation an be considered in `for` statement or `ternary` statements. 
 Or more operations could be considered. Depends on the implementation. 
 
 #### Dataset
 It's present [here](https://github.com/kth-tcs/defects4j-repair-reloaded/tree/comrepair-coming/coming_data/jMutRepair). It will be published later. 
 
 #### Implementation Details

We use two patterns files:
- [binary.xml](https://github.com/SpoonLabs/coming/blob/master/src/main/resources/repairability/JMutRepair/binary.xml):  
    This file is responsible for getting any sort of `UPDATE` in the Binary Operator. For example: `+` -> `-` or left operand is changed
    We don't require to add check of the source and target node of the BinaryOperator having the same class of Operator because changing the class of an operator will result in an uncompilable program.  
    jMutRepair tool can't change the operands of the Binary Operator. We discard instances returned by this pattern if the operand has been changed. This check is applied in [the filter function ofJMutRepair.](https://github.com/SpoonLabs/coming/blob/master/src/main/java/fr/inria/coming/repairability/repiartools/JMutRepair.java)
    
- [unary.xml](https://github.com/SpoonLabs/coming/blob/master/src/main/resources/repairability/JMutRepair/unary.xml)
    This pattern checks for insertion or deletion of any unary operator.
    Possible problems with the current pattern are:
        - increments and decrements can only to be changed/upd but right now insert and delete are also accepted
        - `!` can be inserted or deleted but right now update is also accepted
        - `+`,`-`,`~`(from the perspective of unary operator) are accepted here but they shouldn't be
    
    TODO: To make it better(above points + )


 ### Nopol
 
 Paper: [Nopol: Automatic Repair of Conditional Statement Bugs in Java Programs](https://hal.archives-ouvertes.fr/hal-01285008/file/nopol.pdf)
 
 #### Research Summary
 It fixes two types of bug:
 - Changing if-condition (IF-UPD)
 - Inserting precondition or if-statement (IF-INS)
 
 #### Real-world patches note
 None
 
 #### Dataset
 - [here](https://github.com/kth-tcs/defects4j-repair-reloaded/tree/comrepair-coming/coming_data/Nopol)
 - 103 total patches 
    - 81 patches for insertion of if
    - 22 patches or update in if-condition

 #### Implementation Details
 
 We have four patterns files. Two for IF-INS and two for IF-UPD.
 
**Finding multiple instances for a single pattern in a single diff**
 
The xml below is supposed to match a if-condition update. 
Simply checking entity 2 for a change doesnt't always work. Case: Only one thing deep(wrt AST) within the condition is changed and the entity 2 remains unchanged.
So we search for any sort of change within the condition at any level of children. 
 ```xml
<pattern name="if_condition_upd_deep">

    <entity id="1" type="If"/>
    <entity id="2" type="*" role="condition">
        <parent parentId="1" distance="1"/>
    </entity>
    <entity id="4" type="*">
        <parent parentId="2" distance="1000000"/>
    </entity>
    <action entityId="4" type="*"/>

    <entity id="3" type="*" role="Then">
        <parent parentId="1" distance="1"/>
    </entity>
    <action entityId="3" type="UNCHANGED_HIGH_PRIORITY"/>
</pattern>

```
If the if-condition update is very complicated, the above pattern can produce something like below for even a single if-condition update:
```
[ChangePatternInstance [actions=[Insert VariableRead at com.google.javascript.jscomp.LightweightMessageFormatter:97                                                                              
        error                                                                                                                                                                                    
]], ChangePatternInstance [actions=[Update Literal at com.google.javascript.jscomp.LightweightMessageFormatter:98                                                                                
         to null                                                                                                                                                                                 
]], ChangePatternInstance [actions=[Move Literal from com.google.javascript.jscomp.LightweightMessageFormatter:98 to com.google.javascript.jscomp.LightweightMessageFormatter:97                 
        0                                                                                                                                                                                        
]], ChangePatternInstance [actions=[Delete TypeAccess at com.google.javascript.jscomp.LightweightMessageFormatter                                                                                
        com.google.javascript.jscomp.LightweightMessageFormatter                                                                                                                                 
]], ChangePatternInstance [actions=[Delete FieldRead at com.google.javascript.jscomp.LightweightMessageFormatter:97                                                                              
        excerpt                                                                                                                                                                                  
]], ChangePatternInstance [actions=[Delete TypeAccess at com.google.javascript.jscomp.LightweightMessageFormatter:97                                                                             
        SourceExcerpt.LINE...
```
 
 
 
 ### GenProg
 
 Paper: [GenProg: A Generic Method for Automatic Software Repair](https://ieeexplore.ieee.org/document/6035728)
 
 #### Research Summary
  - It can insert a statement, that is already present in the source code
  - It can delete any statement
  - It can do both of the above.
  - It can swap statements.
  
 #### Real-world patches note
  - We are only considering patches in which the inserted/updated/swapped statement is already preset in the same file
 
 #### Dataset
 - It's present [here](https://github.com/kth-tcs/defects4j-repair-reloaded/tree/comrepair-coming/coming_data/JGenProg)
 - ~23 patches in the above dataset have insert statement that is not present in the source file
 
 #### Implementation Details
 In this module our approach is detect all the actions(i.e. INS, DEL, UPD, or MOV) at statement level.
 If the new statement was present in the previous version of the file, then the instance most probably was generated by JGenProg.
 
 - MOV action can belong to insert + delete action but it can also generate false-positives were statements were moved because of any kind of insertion in other places. 
 Since deleted the x statement and inserting the same x statement is not common in our given dataset we are right now ignoring them[TODO]
 - DEL action is same as described in the paper.
 - INS action(with check if it has occurred before) is same as described in the paper.
 - UPD action can reflect an actual insert move sometime. (For example: When just an extra parameter is added to an already existing line)
 
TODO: Implement checking for the presences of a statement in the previous file at AST level.
 
