diff -rwu ORIGINAL_PATH/src/com/google/javascript/jscomp/ScopedAliases.java MODIFIED_PATH/src/com/google/javascript/jscomp/ScopedAliases.java
--- ORIGINAL_PATH/src/com/google/javascript/jscomp/ScopedAliases.java
+++ MODIFIED_PATH/src/com/google/javascript/jscomp/ScopedAliases.java
@@ -8,6 +8,7 @@
 import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;
 import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;
 import com.google.javascript.jscomp.Scope.Var;
+import com.google.javascript.rhino.IR;
 import com.google.javascript.rhino.JSDocInfo;
 import com.google.javascript.rhino.Node;
 import com.google.javascript.rhino.SourcePosition;
@@ -227,27 +228,45 @@
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
+        boolean isFunctionDecl = NodeUtil.isFunctionDeclarationparent;
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAliasv;
         } else if (v.isBleedingFunction()) {
         } else if (parent.getType() == Token.LP) {
-        } else if isVar {
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclarationparent;
           Node grandparent = parent.getParent();
-          Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;
-          Node varNode = parent;
+          Node value = v.getInitialValue() != null ? v.getInitialValue() : null;
+          Node varNode = null;
           String name = n.getString();
           int nameCount = scopedAliasNames.countname;
           scopedAliasNames.addname;
           String globalName = "$jscomp.scope." + name + (nameCount == 0 ? "" : ("$" + nameCount));
           compiler.ensureLibraryInjected("base");
+          if isFunctionDecl {
+            Node existingName = v.getNameNode();
+            Node newName = IR.name("").useSourceInfoFromexistingName;
+            value.replaceChild(existingName, newName);
+            varNode = IR.varexistingName.useSourceInfoFromexistingName;
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
           if (value != null || v.getJSDocInfo() != null) {
             Node newDecl =
                 NodeUtil.newQualifiedNameNodeDeclaration(
                         compiler.getCodingConvention(), globalName, value, v.getJSDocInfo())
                     .useSourceInfoIfMissingFromForTreen;
             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);
+            if isHoisted {
+              grandparent.addChildToFrontnewDecl;
+            } else {
             grandparent.addChildBefore(newDecl, varNode);
           }
+          }
           v.getNameNode()
               .addChildToFront(
                   NodeUtil.newQualifiedNameNode(
diff -rwu ORIGINAL_PATH/src/com/google/javascript/rhino/Node.java MODIFIED_PATH/src/com/google/javascript/rhino/Node.java
--- ORIGINAL_PATH/src/com/google/javascript/rhino/Node.java
+++ MODIFIED_PATH/src/com/google/javascript/rhino/Node.java
@@ -397,6 +397,9 @@
       return null;
     }
     Node n = first;
+    if (n == null) {
+      throw new RuntimeException("node is not a child");
+    }
     while (n.next != child) {
       n = n.next;
       if (n == null) {
