diff -rwu ORIGINAL_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java MODIFIED_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
--- ORIGINAL_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
+++ MODIFIED_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
@@ -18,6 +18,7 @@
   private double orthoTolerance;
   public LevenbergMarquardtOptimizer() {
     setMaxIterations1000;
+    setConvergenceCheckernull;
     setInitialStepBoundFactor100.0;
     setCostRelativeTolerance(1.0e-10);
     setParRelativeTolerance(1.0e-10);
@@ -55,8 +56,10 @@
     updateResidualsAndCost();
     lmPar = 0;
     boolean firstIteration = true;
+    VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
     while true {
       incrementIterationsCounter();
+      VectorialPointValuePair previous = current;
       updateJacobian();
       qrDecomposition();
       qTyresiduals;
@@ -93,7 +96,7 @@
         }
       }
       if (maxCosine <= orthoTolerance) {
-        return new VectorialPointValuePair(point, objective);
+        return current;
       }
       for (int j = 0; j < cols; ++j) {
         diag[j] = Math.max(diag[j], jacNorm[j]);
@@ -121,6 +124,7 @@
           delta = Math.min(delta, lmNorm);
         }
         updateResidualsAndCost();
+        current = new VectorialPointValuePair(point, objective);
         double actRed = -1.0;
         if (0.1 * cost < previousCost) {
           double r = cost / previousCost;
@@ -173,11 +177,17 @@
           residuals = oldRes;
           oldRes = tmpVec;
         }
+        if (checker != null) {
+          if (checker.converged(getIterations(), previous, current)) {
+            return current;
+          }
+        } else {
         if (((Math.absactRed <= costRelativeTolerance)
                 && (preRed <= costRelativeTolerance)
                 && (ratio <= 2.0))
             || (delta <= parRelativeTolerance * xNorm)) {
-          return new VectorialPointValuePair(point, objective);
+            return current;
+          }
         }
         if ((Math.absactRed <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
           throw new OptimizationException(
