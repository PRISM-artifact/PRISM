diff -rwu ORIGINAL_PATH/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java MODIFIED_PATH/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
--- ORIGINAL_PATH/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
+++ MODIFIED_PATH/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
@@ -1,1654 +0,0 @@
-package com.google.javascript.jscomp.parsing;
-import com.google.common.base.Preconditions;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import com.google.javascript.jscomp.parsing.Config.LanguageMode;
-import com.google.javascript.rhino.IR;
-import com.google.javascript.rhino.JSDocInfo;
-import com.google.javascript.rhino.JSDocInfo.Visibility;
-import com.google.javascript.rhino.JSDocInfoBuilder;
-import com.google.javascript.rhino.JSTypeExpression;
-import com.google.javascript.rhino.Node;
-import com.google.javascript.rhino.ScriptRuntime;
-import com.google.javascript.rhino.Token;
-import com.google.javascript.rhino.head.ErrorReporter;
-import com.google.javascript.rhino.head.ast.Comment;
-import com.google.javascript.rhino.jstype.StaticSourceFile;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-public final class JsDocInfoParser {
-  private final JsDocTokenStream stream;
-  private final JSDocInfoBuilder jsdocBuilder;
-  private final StaticSourceFile sourceFile;
-  private final Node associatedNode;
-  private final ErrorReporter errorReporter;
-  private final ErrorReporterParser parser = new ErrorReporterParser();
-  private final Node templateNode;
-  private class ErrorReporterParser {
-    void addParserWarning(String messageId, String messageArg, int lineno, int charno) {
-      errorReporter.warning(
-          ScriptRuntime.getMessage1(messageId, messageArg), getSourceName(), lineno, null, charno);
-    }
-    void addParserWarning(String messageId, int lineno, int charno) {
-      errorReporter.warning(
-          ScriptRuntime.getMessage0messageId, getSourceName(), lineno, null, charno);
-    }
-    void addTypeWarning(String messageId, String messageArg, int lineno, int charno) {
-      errorReporter.warning(
-          "Bad type annotation. " + ScriptRuntime.getMessage1(messageId, messageArg),
-          getSourceName(),
-          lineno,
-          null,
-          charno);
-    }
-    void addTypeWarning(String messageId, int lineno, int charno) {
-      errorReporter.warning(
-          "Bad type annotation. " + ScriptRuntime.getMessage0messageId,
-          getSourceName(),
-          lineno,
-          null,
-          charno);
-    }
-  }
-  private JSDocInfo fileOverviewJSDocInfo = null;
-  private State state;
-  private final Map<String, Annotation> annotationNames;
-  private final Set<String> suppressionNames;
-  private static final Set<String> modifiesAnnotationKeywords =
-      ImmutableSet.<String>of("this", "arguments");
-  private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;
-  void setFileLevelJsDocBuilder(Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {
-    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;
-  }
-  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {
-    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;
-  }
-  private enum State {
-    SEARCHING_ANNOTATION,
-    SEARCHING_NEWLINE,
-    NEXT_IS_ANNOTATION
-  }
-  JsDocInfoParser(
-      JsDocTokenStream stream,
-      Comment commentNode,
-      Node associatedNode,
-      Config config,
-      ErrorReporter errorReporter) {
-    this.stream = stream;
-    this.associatedNode = associatedNode;
-    this.sourceFile = associatedNode == null ? null : associatedNode.getStaticSourceFile();
-    this.jsdocBuilder = new JSDocInfoBuilderconfig.parseJsDocDocumentation;
-    if (commentNode != null) {
-      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());
-    }
-    this.annotationNames = config.annotationNames;
-    this.suppressionNames = config.suppressionNames;
-    this.errorReporter = errorReporter;
-    this.templateNode = this.createTemplateNode();
-  }
-  private String getSourceName() {
-    return sourceFile == null ? null : sourceFile.getName();
-  }
-  public JSDocInfo parseInlineTypeDoc() {
-    Node typeAst = parseAndRecordTypeNode(next());
-    JSTypeExpression expr = createJSTypeExpressiontypeAst;
-    if (expr != null) {
-      jsdocBuilder.recordTypeexpr;
-      return retrieveAndResetParsedJSDocInfo();
-    }
-    return null;
-  }
-  public static Node parseTypeString(String typeString) {
-    Config config =
-        new Config(
-            Sets.<String>newHashSet(),
-            Sets.<String>newHashSet(),
-            false,
-            LanguageMode.ECMASCRIPT3,
-            false);
-    JsDocInfoParser parser =
-        new JsDocInfoParser(
-            new JsDocTokenStreamtypeString, null, null, config, NullErrorReporter.forNewRhino());
-    return parser.parseTopLevelTypeExpression(parser.next());
-  }
-  @SuppressWarnings("incomplete-switch")
-  boolean parse() {
-    int lineno;
-    int charno;
-    JSTypeExpression type;
-    state = State.SEARCHING_ANNOTATION;
-    skipEOLs();
-    JsDocToken token = next();
-    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();
-    if (jsdocBuilder.shouldParseDocumentation()) {
-      ExtractionInfo blockInfo = extractBlockCommenttoken;
-      token = blockInfo.token;
-      if (!blockInfo.string.isEmpty()) {
-        jsdocBuilder.recordBlockDescriptionblockInfo.string;
-      }
-    } else {
-      if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) {
-        jsdocBuilder.recordBlockDescription("");
-      }
-    }
-    retry:
-    for (; ; ) {
-      switch token {
-        case ANNOTATION:
-          if (state == State.SEARCHING_ANNOTATION) {
-            state = State.SEARCHING_NEWLINE;
-            lineno = stream.getLineno();
-            charno = stream.getCharno();
-            String annotationName = stream.getString();
-            Annotation annotation = annotationNames.getannotationName;
-            if (annotation == null) {
-              parser.addParserWarning(
-                  "msg.bad.jsdoc.tag", annotationName, stream.getLineno(), stream.getCharno());
-            } else {
-              jsdocBuilder.markAnnotation(annotationName, lineno, charno);
-              switch annotation {
-                case NG_INJECT:
-                  if (jsdocBuilder.isNgInjectRecorded()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.nginject.extra", stream.getLineno(), stream.getCharno());
-                  } else {
-                    jsdocBuilder.recordNgInjecttrue;
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case AUTHOR:
-                  if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo authorInfo = extractSingleLineBlock();
-                    String author = authorInfo.string;
-                    if (author.length() == 0) {
-                      parser.addParserWarning(
-                          "msg.jsdoc.authormissing", stream.getLineno(), stream.getCharno());
-                    } else {
-                      jsdocBuilder.addAuthorauthor;
-                    }
-                    token = authorInfo.token;
-                  } else {
-                    token = eatTokensUntilEOLtoken;
-                  }
-                  continue retry;
-                case CONSISTENTIDGENERATOR:
-                  if (!jsdocBuilder.recordConsistentIdGenerator()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.consistidgen", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case STRUCT:
-                  if (!jsdocBuilder.recordStruct()) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case DICT:
-                  if (!jsdocBuilder.recordDict()) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case CONSTRUCTOR:
-                  if (!jsdocBuilder.recordConstructor()) {
-                    if (jsdocBuilder.isInterfaceRecorded()) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.interface.constructor",
-                          stream.getLineno(),
-                          stream.getCharno());
-                    } else {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
-                    }
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case DEPRECATED:
-                  if (!jsdocBuilder.recordDeprecated()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.deprecated", stream.getLineno(), stream.getCharno());
-                  }
-                  ExtractionInfo reasonInfo = extractMultilineTextualBlocktoken;
-                  String reason = reasonInfo.string;
-                  if (reason.length() > 0) {
-                    jsdocBuilder.recordDeprecationReasonreason;
-                  }
-                  token = reasonInfo.token;
-                  continue retry;
-                case INTERFACE:
-                  if (!jsdocBuilder.recordInterface()) {
-                    if (jsdocBuilder.isConstructorRecorded()) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.interface.constructor",
-                          stream.getLineno(),
-                          stream.getCharno());
-                    } else {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.incompat.type", stream.getLineno(), stream.getCharno());
-                    }
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case DESC:
-                  if (jsdocBuilder.isDescriptionRecorded()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.desc.extra", stream.getLineno(), stream.getCharno());
-                    token = eatTokensUntilEOL();
-                    continue retry;
-                  } else {
-                    ExtractionInfo descriptionInfo = extractMultilineTextualBlocktoken;
-                    String description = descriptionInfo.string;
-                    jsdocBuilder.recordDescriptiondescription;
-                    token = descriptionInfo.token;
-                    continue retry;
-                  }
-                case FILE_OVERVIEW:
-                  String fileOverview = "";
-                  if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo fileOverviewInfo =
-                        extractMultilineTextualBlock(token, WhitespaceOption.TRIM);
-                    fileOverview = fileOverviewInfo.string;
-                    token = fileOverviewInfo.token;
-                  } else {
-                    token = eatTokensUntilEOLtoken;
-                  }
-                  if (!jsdocBuilder.recordFileOverviewfileOverview) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.fileoverview.extra", stream.getLineno(), stream.getCharno());
-                  }
-                  continue retry;
-                case LICENSE:
-                case PRESERVE:
-                  ExtractionInfo preserveInfo =
-                      extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE);
-                  String preserve = preserveInfo.string;
-                  if (preserve.length() > 0) {
-                    if (fileLevelJsDocBuilder != null) {
-                      fileLevelJsDocBuilder.appendpreserve;
-                    }
-                  }
-                  token = preserveInfo.token;
-                  continue retry;
-                case ENUM:
-                  token = next();
-                  lineno = stream.getLineno();
-                  charno = stream.getCharno();
-                  type = null;
-                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
-                    type = createJSTypeExpression(parseAndRecordTypeNodetoken);
-                  }
-                  if (type == null) {
-                    type = createJSTypeExpression(newStringNode("number"));
-                  }
-                  if (!jsdocBuilder.recordEnumParameterTypetype) {
-                    parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
-                  }
-                  token = eatTokensUntilEOLtoken;
-                  continue retry;
-                case EXPORT:
-                  if (!jsdocBuilder.recordExport()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.export", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case EXPOSE:
-                  if (!jsdocBuilder.recordExpose()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.expose", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case EXTERNS:
-                  if (!jsdocBuilder.recordExterns()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.externs", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case JAVA_DISPATCH:
-                  if (!jsdocBuilder.recordJavaDispatch()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.javadispatch", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case EXTENDS:
-                case IMPLEMENTS:
-                  skipEOLs();
-                  token = next();
-                  lineno = stream.getLineno();
-                  charno = stream.getCharno();
-                  boolean matchingRc = false;
-                  if (token == JsDocToken.LC) {
-                    token = next();
-                    matchingRc = true;
-                  }
-                  if (token == JsDocToken.STRING) {
-                    Node typeNode = parseAndRecordTypeNameNode(token, lineno, charno, matchingRc);
-                    lineno = stream.getLineno();
-                    charno = stream.getCharno();
-                    typeNode = wrapNode(Token.BANG, typeNode);
-                    type = createJSTypeExpressiontypeNode;
-                    if (annotation == Annotation.EXTENDS) {
-                      extendedTypes.add(
-                          new ExtendedTypeInfo(type, stream.getLineno(), stream.getCharno()));
-                    } else {
-                      Preconditions.checkState(annotation == Annotation.IMPLEMENTS);
-                      if (!jsdocBuilder.recordImplementedInterfacetype) {
-                        parser.addTypeWarning("msg.jsdoc.implements.duplicate", lineno, charno);
-                      }
-                    }
-                    token = next();
-                    if matchingRc {
-                      if (token != JsDocToken.RC) {
-                        parser.addTypeWarning(
-                            "msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno());
-                      }
-                    } else if (token != JsDocToken.EOL
-                        && token != JsDocToken.EOF
-                        && token != JsDocToken.EOC) {
-                      parser.addTypeWarning(
-                          "msg.end.annotation.expected", stream.getLineno(), stream.getCharno());
-                    }
-                  } else {
-                    parser.addTypeWarning("msg.no.type.name", lineno, charno);
-                  }
-                  token = eatTokensUntilEOLtoken;
-                  continue retry;
-                case HIDDEN:
-                  if (!jsdocBuilder.recordHiddenness()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.hidden", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case LENDS:
-                  skipEOLs();
-                  matchingRc = false;
-                  if (matchJsDocToken.LC) {
-                    token = next();
-                    matchingRc = true;
-                  }
-                  if (matchJsDocToken.STRING) {
-                    token = next();
-                    if (!jsdocBuilder.recordLends(stream.getString())) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.lends.incompatible", stream.getLineno(), stream.getCharno());
-                    }
-                  } else {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.lends.missing", stream.getLineno(), stream.getCharno());
-                  }
-                  if (matchingRc && !matchJsDocToken.RC) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.missing.rc", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case MEANING:
-                  ExtractionInfo meaningInfo = extractMultilineTextualBlocktoken;
-                  String meaning = meaningInfo.string;
-                  token = meaningInfo.token;
-                  if (!jsdocBuilder.recordMeaningmeaning) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.meaning.extra", stream.getLineno(), stream.getCharno());
-                  }
-                  continue retry;
-                case NO_ALIAS:
-                  if (!jsdocBuilder.recordNoAlias()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.noalias", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case NO_COMPILE:
-                  if (!jsdocBuilder.recordNoCompile()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.nocompile", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case NO_TYPE_CHECK:
-                  if (!jsdocBuilder.recordNoTypeCheck()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.nocheck", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case NOT_IMPLEMENTED:
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case INHERIT_DOC:
-                case OVERRIDE:
-                  if (!jsdocBuilder.recordOverride()) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.override", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case THROWS:
-                  skipEOLs();
-                  token = next();
-                  lineno = stream.getLineno();
-                  charno = stream.getCharno();
-                  type = null;
-                  if (token == JsDocToken.LC) {
-                    type = createJSTypeExpression(parseAndRecordTypeNodetoken);
-                    if (type == null) {
-                      token = eatTokensUntilEOL();
-                      continue retry;
-                    }
-                  }
-                  token = current();
-                  jsdocBuilder.recordThrowTypetype;
-                  if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo descriptionInfo = extractMultilineTextualBlocktoken;
-                    String description = descriptionInfo.string;
-                    if (description.length() > 0) {
-                      jsdocBuilder.recordThrowDescription(type, description);
-                    }
-                    token = descriptionInfo.token;
-                  } else {
-                    token = eatTokensUntilEOLtoken;
-                  }
-                  continue retry;
-                case PARAM:
-                  skipEOLs();
-                  token = next();
-                  lineno = stream.getLineno();
-                  charno = stream.getCharno();
-                  type = null;
-                  if (token == JsDocToken.LC) {
-                    type = createJSTypeExpression(parseAndRecordParamTypeNodetoken);
-                    if (type == null) {
-                      token = eatTokensUntilEOL();
-                      continue retry;
-                    }
-                    skipEOLs();
-                    token = next();
-                    lineno = stream.getLineno();
-                    charno = stream.getCharno();
-                  }
-                  String name = null;
-                  boolean isBracketedParam = JsDocToken.LB == token;
-                  if isBracketedParam {
-                    token = next();
-                  }
-                  if (JsDocToken.STRING != token) {
-                    parser.addTypeWarning("msg.missing.variable.name", lineno, charno);
-                  } else {
-                    name = stream.getString();
-                    if isBracketedParam {
-                      token = next();
-                      if (JsDocToken.EQUALS == token) {
-                        token = next();
-                        if (JsDocToken.STRING == token) {
-                          token = next();
-                        }
-                      }
-                      if (JsDocToken.RB != token) {
-                        reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
-                      } else if (type != null) {
-                        type = JSTypeExpression.makeOptionalArgtype;
-                      }
-                    }
-                    if (name.indexOf('.') > -1) {
-                      name = null;
-                    } else if (!jsdocBuilder.recordParameter(name, type)) {
-                      if (jsdocBuilder.hasParametername) {
-                        parser.addTypeWarning("msg.dup.variable.name", name, lineno, charno);
-                      } else {
-                        parser.addTypeWarning("msg.jsdoc.incompat.type", name, lineno, charno);
-                      }
-                    }
-                  }
-                  if (name == null) {
-                    token = eatTokensUntilEOLtoken;
-                    continue retry;
-                  }
-                  jsdocBuilder.markName(name, sourceFile, lineno, charno);
-                  if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlocktoken;
-                    String paramDescription = paramDescriptionInfo.string;
-                    if (paramDescription.length() > 0) {
-                      jsdocBuilder.recordParameterDescription(name, paramDescription);
-                    }
-                    token = paramDescriptionInfo.token;
-                  } else {
-                    token = eatTokensUntilEOLtoken;
-                  }
-                  continue retry;
-                case PRESERVE_TRY:
-                  if (!jsdocBuilder.recordPreserveTry()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.preservertry", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case NO_SHADOW:
-                  if (!jsdocBuilder.recordNoShadow()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.noshadow", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case NO_SIDE_EFFECTS:
-                  if (!jsdocBuilder.recordNoSideEffects()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.nosideeffects", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case MODIFIES:
-                  token = parseModifiesTag(next());
-                  continue retry;
-                case IMPLICIT_CAST:
-                  if (!jsdocBuilder.recordImplicitCast()) {
-                    parser.addTypeWarning(
-                        "msg.jsdoc.implicitcast", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case SEE:
-                  if (jsdocBuilder.shouldParseDocumentation()) {
-                    ExtractionInfo referenceInfo = extractSingleLineBlock();
-                    String reference = referenceInfo.string;
-                    if (reference.length() == 0) {
-                      parser.addParserWarning(
-                          "msg.jsdoc.seemissing", stream.getLineno(), stream.getCharno());
-                    } else {
-                      jsdocBuilder.addReferencereference;
-                    }
-                    token = referenceInfo.token;
-                  } else {
-                    token = eatTokensUntilEOLtoken;
-                  }
-                  continue retry;
-                case STABLEIDGENERATOR:
-                  if (!jsdocBuilder.recordStableIdGenerator()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.stableidgen", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case SUPPRESS:
-                  token = parseSuppressTag(next());
-                  continue retry;
-                case TEMPLATE:
-                  {
-                    ExtractionInfo templateInfo = extractSingleLineBlock();
-                    List<String> names =
-                        Lists.newArrayList(
-                            Splitter.on(',').trimResults().splittemplateInfo.string);
-                    if (names.size() == 0 || names.get0.length() == 0) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.templatemissing", stream.getLineno(), stream.getCharno());
-                    } else if (!jsdocBuilder.recordTemplateTypeNamesnames) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.template.at.most.once",
-                          stream.getLineno(),
-                          stream.getCharno());
-                    }
-                    token = templateInfo.token;
-                    continue retry;
-                  }
-                case CLASS_TEMPLATE:
-                  {
-                    ExtractionInfo classTemplateInfo = extractSingleLineBlock();
-                    List<String> names =
-                        Lists.newArrayList(
-                            Splitter.on(',').trimResults().splitclassTemplateInfo.string);
-                    if (names.size() == 0 || names.get0.length() == 0) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.classtemplate.missing.type.name",
-                          stream.getLineno(),
-                          stream.getCharno());
-                    } else if (!jsdocBuilder.recordClassTemplateTypeNamesnames) {
-                      parser.addTypeWarning(
-                          "msg.jsdoc.classtemplate.at.most.once",
-                          stream.getLineno(),
-                          stream.getCharno());
-                    }
-                    token = classTemplateInfo.token;
-                    continue retry;
-                  }
-                case IDGENERATOR:
-                  if (!jsdocBuilder.recordIdGenerator()) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.idgen", stream.getLineno(), stream.getCharno());
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-                case VERSION:
-                  ExtractionInfo versionInfo = extractSingleLineBlock();
-                  String version = versionInfo.string;
-                  if (version.length() == 0) {
-                    parser.addParserWarning(
-                        "msg.jsdoc.versionmissing", stream.getLineno(), stream.getCharno());
-                  } else {
-                    if (!jsdocBuilder.recordVersionversion) {
-                      parser.addParserWarning(
-                          "msg.jsdoc.extraversion", stream.getLineno(), stream.getCharno());
-                    }
-                  }
-                  token = versionInfo.token;
-                  continue retry;
-                case CONSTANT:
-                case DEFINE:
-                case RETURN:
-                case PRIVATE:
-                case PROTECTED:
-                case PUBLIC:
-                case THIS:
-                case TYPE:
-                case TYPEDEF:
-                  lineno = stream.getLineno();
-                  charno = stream.getCharno();
-                  Node typeNode = null;
-                  boolean hasType = lookAheadForTypeAnnotation();
-                  boolean isAlternateTypeAnnotation =
-                      (annotation == Annotation.PRIVATE
-                          || annotation == Annotation.PROTECTED
-                          || annotation == Annotation.PUBLIC
-                          || annotation == Annotation.CONSTANT);
-                  boolean canSkipTypeAnnotation =
-                      (isAlternateTypeAnnotation || annotation == Annotation.RETURN);
-                  type = null;
-                  if (hasType || !canSkipTypeAnnotation) {
-                    skipEOLs();
-                    token = next();
-                    typeNode = parseAndRecordTypeNodetoken;
-                    if (annotation == Annotation.THIS) {
-                      typeNode = wrapNode(Token.BANG, typeNode);
-                    }
-                    type = createJSTypeExpressiontypeNode;
-                  }
-                  boolean hasError = type == null && !canSkipTypeAnnotation;
-                  if (!hasError) {
-                    if ((type != null && isAlternateTypeAnnotation)
-                        || annotation == Annotation.TYPE) {
-                      if (!jsdocBuilder.recordTypetype) {
-                        parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
-                      }
-                    }
-                    switch annotation {
-                      case CONSTANT:
-                        if (!jsdocBuilder.recordConstancy()) {
-                          parser.addParserWarning(
-                              "msg.jsdoc.const", stream.getLineno(), stream.getCharno());
-                        }
-                        break;
-                      case DEFINE:
-                        if (!jsdocBuilder.recordDefineTypetype) {
-                          parser.addParserWarning("msg.jsdoc.define", lineno, charno);
-                        }
-                        break;
-                      case PRIVATE:
-                        if (!jsdocBuilder.recordVisibilityVisibility.PRIVATE) {
-                          parser.addParserWarning("msg.jsdoc.visibility.private", lineno, charno);
-                        }
-                        break;
-                      case PROTECTED:
-                        if (!jsdocBuilder.recordVisibilityVisibility.PROTECTED) {
-                          parser.addParserWarning("msg.jsdoc.visibility.protected", lineno, charno);
-                        }
-                        break;
-                      case PUBLIC:
-                        if (!jsdocBuilder.recordVisibilityVisibility.PUBLIC) {
-                          parser.addParserWarning("msg.jsdoc.visibility.public", lineno, charno);
-                        }
-                        break;
-                      case RETURN:
-                        if (type == null) {
-                          type = createJSTypeExpression(newNodeToken.QMARK);
-                        }
-                        if (!jsdocBuilder.recordReturnTypetype) {
-                          parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
-                          break;
-                        }
-                        if (jsdocBuilder.shouldParseDocumentation()) {
-                          ExtractionInfo returnDescriptionInfo =
-                              extractMultilineTextualBlocktoken;
-                          String returnDescription = returnDescriptionInfo.string;
-                          if (returnDescription.length() > 0) {
-                            jsdocBuilder.recordReturnDescriptionreturnDescription;
-                          }
-                          token = returnDescriptionInfo.token;
-                        } else {
-                          token = eatTokensUntilEOLtoken;
-                        }
-                        continue retry;
-                      case THIS:
-                        if (!jsdocBuilder.recordThisTypetype) {
-                          parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
-                        }
-                        break;
-                      case TYPEDEF:
-                        if (!jsdocBuilder.recordTypedeftype) {
-                          parser.addTypeWarning("msg.jsdoc.incompat.type", lineno, charno);
-                        }
-                        break;
-                    }
-                  }
-                  token = eatTokensUntilEOL();
-                  continue retry;
-              }
-            }
-          }
-          break;
-        case EOC:
-          if (hasParsedFileOverviewDocInfo()) {
-            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
-          }
-          checkExtendedTypesextendedTypes;
-          return true;
-        case EOF:
-          jsdocBuilder.buildnull;
-          parser.addParserWarning("msg.unexpected.eof", stream.getLineno(), stream.getCharno());
-          checkExtendedTypesextendedTypes;
-          return false;
-        case EOL:
-          if (state == State.SEARCHING_NEWLINE) {
-            state = State.SEARCHING_ANNOTATION;
-          }
-          token = next();
-          continue retry;
-        default:
-          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
-            token = next();
-            continue retry;
-          } else {
-            state = State.SEARCHING_NEWLINE;
-            token = eatTokensUntilEOL();
-            continue retry;
-          }
-      }
-      token = next();
-    }
-  }
-  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {
-    for (ExtendedTypeInfo typeInfo : extendedTypes) {
-      if (jsdocBuilder.isInterfaceRecorded()) {
-        if (!jsdocBuilder.recordExtendedInterfacetypeInfo.type) {
-          parser.addParserWarning("msg.jsdoc.extends.duplicate", typeInfo.lineno, typeInfo.charno);
-        }
-      } else {
-        if (!jsdocBuilder.recordBaseTypetypeInfo.type) {
-          parser.addTypeWarning("msg.jsdoc.incompat.type", typeInfo.lineno, typeInfo.charno);
-        }
-      }
-    }
-  }
-  private JsDocToken parseSuppressTag(JsDocToken token) {
-    if (token == JsDocToken.LC) {
-      Set<String> suppressions = new HashSet<String>();
-      while true {
-        if (matchJsDocToken.STRING) {
-          String name = stream.getString();
-          if (!suppressionNames.containsname) {
-            parser.addParserWarning(
-                "msg.jsdoc.suppress.unknown", name, stream.getLineno(), stream.getCharno());
-          }
-          suppressions.add(stream.getString());
-          token = next();
-        } else {
-          parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno());
-          return token;
-        }
-        if (matchJsDocToken.PIPE) {
-          token = next();
-        } else {
-          break;
-        }
-      }
-      if (!matchJsDocToken.RC) {
-        parser.addParserWarning("msg.jsdoc.suppress", stream.getLineno(), stream.getCharno());
-      } else {
-        token = next();
-        if (!jsdocBuilder.recordSuppressionssuppressions) {
-          parser.addParserWarning(
-              "msg.jsdoc.suppress.duplicate", stream.getLineno(), stream.getCharno());
-        }
-      }
-    }
-    return token;
-  }
-  private JsDocToken parseModifiesTag(JsDocToken token) {
-    if (token == JsDocToken.LC) {
-      Set<String> modifies = new HashSet<String>();
-      while true {
-        if (matchJsDocToken.STRING) {
-          String name = stream.getString();
-          if (!modifiesAnnotationKeywords.containsname && !jsdocBuilder.hasParametername) {
-            parser.addParserWarning(
-                "msg.jsdoc.modifies.unknown", name, stream.getLineno(), stream.getCharno());
-          }
-          modifies.add(stream.getString());
-          token = next();
-        } else {
-          parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno());
-          return token;
-        }
-        if (matchJsDocToken.PIPE) {
-          token = next();
-        } else {
-          break;
-        }
-      }
-      if (!matchJsDocToken.RC) {
-        parser.addParserWarning("msg.jsdoc.modifies", stream.getLineno(), stream.getCharno());
-      } else {
-        token = next();
-        if (!jsdocBuilder.recordModifiesmodifies) {
-          parser.addParserWarning(
-              "msg.jsdoc.modifies.duplicate", stream.getLineno(), stream.getCharno());
-        }
-      }
-    }
-    return token;
-  }
-  Node parseAndRecordTypeNode(JsDocToken token) {
-    return parseAndRecordTypeNode(token, token == JsDocToken.LC);
-  }
-  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {
-    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(), matchingLC, false);
-  }
-  private Node parseAndRecordTypeNameNode(
-      JsDocToken token, int lineno, int startCharno, boolean matchingLC) {
-    return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);
-  }
-  private Node parseAndRecordParamTypeNode(JsDocToken token) {
-    Preconditions.checkArgument(token == JsDocToken.LC);
-    int lineno = stream.getLineno();
-    int startCharno = stream.getCharno();
-    Node typeNode = parseParamTypeExpressionAnnotationtoken;
-    if (typeNode != null) {
-      int endLineno = stream.getLineno();
-      int endCharno = stream.getCharno();
-      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, true);
-    }
-    return typeNode;
-  }
-  private Node parseAndRecordTypeNode(
-      JsDocToken token,
-      int lineno,
-      int startCharno,
-      boolean matchingLC,
-      boolean onlyParseSimpleNames) {
-    Node typeNode = null;
-    if onlyParseSimpleNames {
-      typeNode = parseTypeNameAnnotationtoken;
-    } else {
-      typeNode = parseTypeExpressionAnnotationtoken;
-    }
-    if (typeNode != null) {
-      int endLineno = stream.getLineno();
-      int endCharno = stream.getCharno();
-      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);
-    }
-    return typeNode;
-  }
-  private String toString(JsDocToken token) {
-    switch token {
-      case ANNOTATION:
-        return "@" + stream.getString();
-      case BANG:
-        return "!";
-      case COMMA:
-        return ",";
-      case COLON:
-        return ":";
-      case GT:
-        return ">";
-      case LB:
-        return "[";
-      case LC:
-        return "{";
-      case LP:
-        return "(";
-      case LT:
-        return ".<";
-      case QMARK:
-        return "?";
-      case PIPE:
-        return "|";
-      case RB:
-        return "]";
-      case RC:
-        return "}";
-      case RP:
-        return ")";
-      case STAR:
-        return "*";
-      case ELLIPSIS:
-        return "...";
-      case EQUALS:
-        return "=";
-      case STRING:
-        return stream.getString();
-      default:
-        throw new IllegalStateException(token.toString());
-    }
-  }
-  JSTypeExpression createJSTypeExpression(Node n) {
-    return n == null ? null : new JSTypeExpression(n, getSourceName());
-  }
-  private static class ExtractionInfo {
-    private final String string;
-    private final JsDocToken token;
-    public ExtractionInfo(String string, JsDocToken token) {
-      this.string = string;
-      this.token = token;
-    }
-  }
-  private static class ExtendedTypeInfo {
-    final JSTypeExpression type;
-    final int lineno;
-    final int charno;
-    public ExtendedTypeInfo(JSTypeExpression type, int lineno, int charno) {
-      this.type = type;
-      this.lineno = lineno;
-      this.charno = charno;
-    }
-  }
-  private ExtractionInfo extractSingleLineBlock() {
-    stream.update();
-    int lineno = stream.getLineno();
-    int charno = stream.getCharno() + 1;
-    String line = getRemainingJSDocLine().trim();
-    if (line.length() > 0) {
-      jsdocBuilder.markText(line, lineno, charno, lineno, charno + line.length());
-    }
-    return new ExtractionInfo(line, next());
-  }
-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {
-    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);
-  }
-  private enum WhitespaceOption {
-    PRESERVE,
-    TRIM,
-    SINGLE_LINE
-  }
-  @SuppressWarnings("fallthrough")
-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {
-    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {
-      return new ExtractionInfo("", token);
-    }
-    stream.update();
-    int startLineno = stream.getLineno();
-    int startCharno = stream.getCharno() + 1;
-    String line = getRemainingJSDocLine();
-    if (option != WhitespaceOption.PRESERVE) {
-      line = line.trim();
-    }
-    StringBuilder builder = new StringBuilder();
-    builder.appendline;
-    state = State.SEARCHING_ANNOTATION;
-    token = next();
-    boolean ignoreStar = false;
-    int lineStartChar = -1;
-    do {
-      switch token {
-        case STAR:
-          if ignoreStar {
-            lineStartChar = stream.getCharno() + 1;
-          } else {
-            if (builder.length() > 0) {
-              builder.append(' ');
-            }
-            builder.append('*');
-          }
-          token = next();
-          continue;
-        case EOL:
-          if (option != WhitespaceOption.SINGLE_LINE) {
-            builder.append("\n");
-          }
-          ignoreStar = true;
-          lineStartChar = 0;
-          token = next();
-          continue;
-        default:
-          ignoreStar = false;
-          state = State.SEARCHING_ANNOTATION;
-          boolean isEOC = token == JsDocToken.EOC;
-          if (!isEOC) {
-            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
-              int numSpaces = stream.getCharno() - lineStartChar;
-              for (int i = 0; i < numSpaces; i++) {
-                builder.append(' ');
-              }
-              lineStartChar = -1;
-            } else if (builder.length() > 0) {
-              builder.append(' ');
-            }
-          }
-          if (token == JsDocToken.EOC
-              || token == JsDocToken.EOF
-              ||
-              (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {
-            String multilineText = builder.toString();
-            if (option != WhitespaceOption.PRESERVE) {
-              multilineText = multilineText.trim();
-            }
-            int endLineno = stream.getLineno();
-            int endCharno = stream.getCharno();
-            if (multilineText.length() > 0) {
-              jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);
-            }
-            return new ExtractionInfo(multilineText, token);
-          }
-          builder.append(toStringtoken);
-          line = getRemainingJSDocLine();
-          if (option != WhitespaceOption.PRESERVE) {
-            line = trimEndline;
-          }
-          builder.appendline;
-          token = next();
-      }
-    } while true;
-  }
-  private ExtractionInfo extractBlockComment(JsDocToken token) {
-    StringBuilder builder = new StringBuilder();
-    boolean ignoreStar = true;
-    do {
-      switch token {
-        case ANNOTATION:
-        case EOC:
-        case EOF:
-          return new ExtractionInfo(builder.toString().trim(), token);
-        case STAR:
-          if (!ignoreStar) {
-            if (builder.length() > 0) {
-              builder.append(' ');
-            }
-            builder.append('*');
-          }
-          token = next();
-          continue;
-        case EOL:
-          ignoreStar = true;
-          builder.append('\n');
-          token = next();
-          continue;
-        default:
-          if (!ignoreStar && builder.length() > 0) {
-            builder.append(' ');
-          }
-          ignoreStar = false;
-          builder.append(toStringtoken);
-          String line = getRemainingJSDocLine();
-          line = trimEndline;
-          builder.appendline;
-          token = next();
-      }
-    } while true;
-  }
-  private static String trimEnd(String s) {
-    int trimCount = 0;
-    while (trimCount < s.length()) {
-      char ch = s.charAt(s.length() - trimCount - 1);
-      if (Character.isWhitespacech) {
-        trimCount++;
-      } else {
-        break;
-      }
-    }
-    if (trimCount == 0) {
-      return s;
-    }
-    return s.substring(0, s.length() - trimCount);
-  }
-  private Node parseTypeExpressionAnnotation(JsDocToken token) {
-    if (token == JsDocToken.LC) {
-      skipEOLs();
-      Node typeNode = parseTopLevelTypeExpression(next());
-      if (typeNode != null) {
-        skipEOLs();
-        if (!matchJsDocToken.RC) {
-          reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
-        } else {
-          next();
-        }
-      }
-      return typeNode;
-    } else {
-      return parseTypeExpressiontoken;
-    }
-  }
-  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {
-    Preconditions.checkArgument(token == JsDocToken.LC);
-    skipEOLs();
-    boolean restArg = false;
-    token = next();
-    if (token == JsDocToken.ELLIPSIS) {
-      token = next();
-      if (token == JsDocToken.RC) {
-        return wrapNode(Token.ELLIPSIS, IR.empty());
-      }
-      restArg = true;
-    }
-    Node typeNode = parseTopLevelTypeExpressiontoken;
-    if (typeNode != null) {
-      skipEOLs();
-      if restArg {
-        typeNode = wrapNode(Token.ELLIPSIS, typeNode);
-      } else if (matchJsDocToken.EQUALS) {
-        next();
-        skipEOLs();
-        typeNode = wrapNode(Token.EQUALS, typeNode);
-      }
-      if (!matchJsDocToken.RC) {
-        reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
-      } else {
-        next();
-      }
-    }
-    return typeNode;
-  }
-  private Node parseTypeNameAnnotation(JsDocToken token) {
-    if (token == JsDocToken.LC) {
-      skipEOLs();
-      Node typeNode = parseTypeName(next());
-      if (typeNode != null) {
-        skipEOLs();
-        if (!matchJsDocToken.RC) {
-          reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
-        } else {
-          next();
-        }
-      }
-      return typeNode;
-    } else {
-      return parseTypeNametoken;
-    }
-  }
-  private Node parseTopLevelTypeExpression(JsDocToken token) {
-    Node typeExpr = parseTypeExpressiontoken;
-    if (typeExpr != null) {
-      if (matchJsDocToken.PIPE) {
-        next();
-        if (matchJsDocToken.PIPE) {
-          next();
-        }
-        skipEOLs();
-        token = next();
-        return parseUnionTypeWithAlternate(token, typeExpr);
-      }
-    }
-    return typeExpr;
-  }
-  private Node parseTypeExpressionList(JsDocToken token) {
-    Node typeExpr = parseTopLevelTypeExpressiontoken;
-    if (typeExpr == null) {
-      return null;
-    }
-    Node typeList = IR.block();
-    typeList.addChildToBacktypeExpr;
-    while (matchJsDocToken.COMMA) {
-      next();
-      skipEOLs();
-      typeExpr = parseTopLevelTypeExpression(next());
-      if (typeExpr == null) {
-        return null;
-      }
-      typeList.addChildToBacktypeExpr;
-    }
-    return typeList;
-  }
-  private Node parseTypeExpression(JsDocToken token) {
-    if (token == JsDocToken.QMARK) {
-      token = next();
-      if (token == JsDocToken.COMMA
-          || token == JsDocToken.EQUALS
-          || token == JsDocToken.RB
-          || token == JsDocToken.RC
-          || token == JsDocToken.RP
-          || token == JsDocToken.PIPE
-          || token == JsDocToken.GT) {
-        restoreLookAheadtoken;
-        return newNodeToken.QMARK;
-      }
-      return wrapNode(Token.QMARK, parseBasicTypeExpressiontoken);
-    } else if (token == JsDocToken.BANG) {
-      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));
-    } else {
-      Node basicTypeExpr = parseBasicTypeExpressiontoken;
-      if (basicTypeExpr != null) {
-        if (matchJsDocToken.QMARK) {
-          next();
-          return wrapNode(Token.QMARK, basicTypeExpr);
-        } else if (matchJsDocToken.BANG) {
-          next();
-          return wrapNode(Token.BANG, basicTypeExpr);
-        }
-      }
-      return basicTypeExpr;
-    }
-  }
-  private Node parseBasicTypeExpression(JsDocToken token) {
-    if (token == JsDocToken.STAR) {
-      return newNodeToken.STAR;
-    } else if (token == JsDocToken.LB) {
-      skipEOLs();
-      return parseArrayType(next());
-    } else if (token == JsDocToken.LC) {
-      skipEOLs();
-      return parseRecordType(next());
-    } else if (token == JsDocToken.LP) {
-      skipEOLs();
-      return parseUnionType(next());
-    } else if (token == JsDocToken.STRING) {
-      String string = stream.getString();
-      if ("function".equalsstring) {
-        skipEOLs();
-        return parseFunctionType(next());
-      } else if ("null".equalsstring || "undefined".equalsstring) {
-        return newStringNodestring;
-      } else {
-        return parseTypeNametoken;
-      }
-    }
-    restoreLookAheadtoken;
-    return reportGenericTypeSyntaxWarning();
-  }
-  private Node parseTypeName(JsDocToken token) {
-    if (token != JsDocToken.STRING) {
-      return reportGenericTypeSyntaxWarning();
-    }
-    String typeName = stream.getString();
-    int lineno = stream.getLineno();
-    int charno = stream.getCharno();
-    while (matchJsDocToken.EOL && typeName.charAt(typeName.length() - 1) == '.') {
-      skipEOLs();
-      if (matchJsDocToken.STRING) {
-        next();
-        typeName += stream.getString();
-      }
-    }
-    Node typeNameNode = newStringNode(typeName, lineno, charno);
-    if (matchJsDocToken.LT) {
-      next();
-      skipEOLs();
-      Node memberType = parseTypeExpressionList(next());
-      if (memberType != null) {
-        typeNameNode.addChildToFrontmemberType;
-        skipEOLs();
-        if (!matchJsDocToken.GT) {
-          return reportTypeSyntaxWarning("msg.jsdoc.missing.gt");
-        }
-        next();
-      }
-    }
-    return typeNameNode;
-  }
-  private Node parseFunctionType(JsDocToken token) {
-    if (token != JsDocToken.LP) {
-      restoreLookAheadtoken;
-      return reportTypeSyntaxWarning("msg.jsdoc.missing.lp");
-    }
-    Node functionType = newNodeToken.FUNCTION;
-    Node parameters = null;
-    skipEOLs();
-    if (!matchJsDocToken.RP) {
-      token = next();
-      boolean hasParams = true;
-      if (token == JsDocToken.STRING) {
-        String tokenStr = stream.getString();
-        boolean isThis = "this".equalstokenStr;
-        boolean isNew = "new".equalstokenStr;
-        if (isThis || isNew) {
-          if (matchJsDocToken.COLON) {
-            next();
-            skipEOLs();
-            Node contextType = wrapNode(isThis ? Token.THIS : Token.NEW, parseTypeName(next()));
-            if (contextType == null) {
-              return null;
-            }
-            functionType.addChildToFrontcontextType;
-          } else {
-            return reportTypeSyntaxWarning("msg.jsdoc.missing.colon");
-          }
-          if (matchJsDocToken.COMMA) {
-            next();
-            skipEOLs();
-            token = next();
-          } else {
-            hasParams = false;
-          }
-        }
-      }
-      if hasParams {
-        parameters = parseParametersTypetoken;
-        if (parameters == null) {
-          return null;
-        }
-      }
-    }
-    if (parameters != null) {
-      functionType.addChildToBackparameters;
-    }
-    skipEOLs();
-    if (!matchJsDocToken.RP) {
-      return reportTypeSyntaxWarning("msg.jsdoc.missing.rp");
-    }
-    skipEOLs();
-    Node resultType = parseResultType(next());
-    if (resultType == null) {
-      return null;
-    } else {
-      functionType.addChildToBackresultType;
-    }
-    return functionType;
-  }
-  private Node parseParametersType(JsDocToken token) {
-    Node paramsType = newNodeToken.PARAM_LIST;
-    boolean isVarArgs = false;
-    Node paramType = null;
-    if (token != JsDocToken.RP) {
-      do {
-        if (paramType != null) {
-          next();
-          skipEOLs();
-          token = next();
-        }
-        if (token == JsDocToken.ELLIPSIS) {
-          skipEOLs();
-          if (matchJsDocToken.RP) {
-            paramType = newNodeToken.ELLIPSIS;
-          } else {
-            skipEOLs();
-            if (!matchJsDocToken.LB) {
-              return reportTypeSyntaxWarning("msg.jsdoc.missing.lb");
-            }
-            next();
-            skipEOLs();
-            paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));
-            skipEOLs();
-            if (!matchJsDocToken.RB) {
-              return reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
-            }
-            skipEOLs();
-            next();
-          }
-          isVarArgs = true;
-        } else {
-          paramType = parseTypeExpressiontoken;
-          if (matchJsDocToken.EQUALS) {
-            skipEOLs();
-            next();
-            paramType = wrapNode(Token.EQUALS, paramType);
-          }
-        }
-        if (paramType == null) {
-          return null;
-        }
-        paramsType.addChildToBackparamType;
-        if isVarArgs {
-          break;
-        }
-      } while (matchJsDocToken.COMMA);
-    }
-    if (isVarArgs && matchJsDocToken.COMMA) {
-      return reportTypeSyntaxWarning("msg.jsdoc.function.varargs");
-    }
-    return paramsType;
-  }
-  private Node parseResultType(JsDocToken token) {
-    skipEOLs();
-    if (!matchJsDocToken.COLON) {
-      return newNodeToken.EMPTY;
-    }
-    token = next();
-    skipEOLs();
-    if (matchJsDocToken.STRING && "void".equals(stream.getString())) {
-      next();
-      return newNodeToken.VOID;
-    } else {
-      return parseTypeExpression(next());
-    }
-  }
-  private Node parseUnionType(JsDocToken token) {
-    return parseUnionTypeWithAlternate(token, null);
-  }
-  private Node parseUnionTypeWithAlternate(JsDocToken token, Node alternate) {
-    Node union = newNodeToken.PIPE;
-    if (alternate != null) {
-      union.addChildToBackalternate;
-    }
-    Node expr = null;
-    do {
-      if (expr != null) {
-        skipEOLs();
-        token = next();
-        Preconditions.checkState(token == JsDocToken.PIPE || token == JsDocToken.COMMA);
-        boolean isPipe = token == JsDocToken.PIPE;
-        if (isPipe && matchJsDocToken.PIPE) {
-          next();
-        }
-        skipEOLs();
-        token = next();
-      }
-      expr = parseTypeExpressiontoken;
-      if (expr == null) {
-        return null;
-      }
-      union.addChildToBackexpr;
-    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));
-    if (alternate == null) {
-      skipEOLs();
-      if (!matchJsDocToken.RP) {
-        return reportTypeSyntaxWarning("msg.jsdoc.missing.rp");
-      }
-      next();
-    }
-    return union;
-  }
-  private Node parseArrayType(JsDocToken token) {
-    Node array = newNodeToken.LB;
-    Node arg = null;
-    boolean hasVarArgs = false;
-    do {
-      if (arg != null) {
-        next();
-        skipEOLs();
-        token = next();
-      }
-      if (token == JsDocToken.ELLIPSIS) {
-        arg = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));
-        hasVarArgs = true;
-      } else {
-        arg = parseTypeExpressiontoken;
-      }
-      if (arg == null) {
-        return null;
-      }
-      array.addChildToBackarg;
-      if hasVarArgs {
-        break;
-      }
-      skipEOLs();
-    } while (matchJsDocToken.COMMA);
-    if (!matchJsDocToken.RB) {
-      return reportTypeSyntaxWarning("msg.jsdoc.missing.rb");
-    }
-    next();
-    return array;
-  }
-  private Node parseRecordType(JsDocToken token) {
-    Node recordType = newNodeToken.LC;
-    Node fieldTypeList = parseFieldTypeListtoken;
-    if (fieldTypeList == null) {
-      return reportGenericTypeSyntaxWarning();
-    }
-    skipEOLs();
-    if (!matchJsDocToken.RC) {
-      return reportTypeSyntaxWarning("msg.jsdoc.missing.rc");
-    }
-    next();
-    recordType.addChildToBackfieldTypeList;
-    return recordType;
-  }
-  private Node parseFieldTypeList(JsDocToken token) {
-    Node fieldTypeList = newNodeToken.LB;
-    do {
-      Node fieldType = parseFieldTypetoken;
-      if (fieldType == null) {
-        return null;
-      }
-      fieldTypeList.addChildToBackfieldType;
-      skipEOLs();
-      if (!matchJsDocToken.COMMA) {
-        break;
-      }
-      next();
-      skipEOLs();
-      token = next();
-    } while true;
-    return fieldTypeList;
-  }
-  private Node parseFieldType(JsDocToken token) {
-    Node fieldName = parseFieldNametoken;
-    if (fieldName == null) {
-      return null;
-    }
-    skipEOLs();
-    if (!matchJsDocToken.COLON) {
-      return fieldName;
-    }
-    next();
-    skipEOLs();
-    Node typeExpression = parseTypeExpression(next());
-    if (typeExpression == null) {
-      return null;
-    }
-    Node fieldType = newNodeToken.COLON;
-    fieldType.addChildToBackfieldName;
-    fieldType.addChildToBacktypeExpression;
-    return fieldType;
-  }
-  private Node parseFieldName(JsDocToken token) {
-    switch token {
-      case STRING:
-        String string = stream.getString();
-        return newStringNodestring;
-      default:
-        return null;
-    }
-  }
-  private Node wrapNode(int type, Node n) {
-    return n == null
-        ? null
-        : new Node(type, n, stream.getLineno(), stream.getCharno()).clonePropsFromtemplateNode;
-  }
-  private Node newNode(int type) {
-    return new Node(type, stream.getLineno(), stream.getCharno()).clonePropsFromtemplateNode;
-  }
-  private Node newStringNode(String s) {
-    return newStringNode(s, stream.getLineno(), stream.getCharno());
-  }
-  private Node newStringNode(String s, int lineno, int charno) {
-    Node n = Node.newString(s, lineno, charno).clonePropsFromtemplateNode;
-    n.setLength(s.length());
-    return n;
-  }
-  private Node createTemplateNode() {
-    Node templateNode = IR.script();
-    templateNode.setStaticSourceFile(
-        this.associatedNode != null ? this.associatedNode.getStaticSourceFile() : null);
-    return templateNode;
-  }
-  private Node reportTypeSyntaxWarning(String warning) {
-    parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());
-    return null;
-  }
-  private Node reportGenericTypeSyntaxWarning() {
-    return reportTypeSyntaxWarning("msg.jsdoc.type.syntax");
-  }
-  private JsDocToken eatTokensUntilEOL() {
-    return eatTokensUntilEOL(next());
-  }
-  private JsDocToken eatTokensUntilEOL(JsDocToken token) {
-    do {
-      if (token == JsDocToken.EOL || token == JsDocToken.EOC || token == JsDocToken.EOF) {
-        state = State.SEARCHING_ANNOTATION;
-        return token;
-      }
-      token = next();
-    } while true;
-  }
-  private static final JsDocToken NO_UNREAD_TOKEN = null;
-  private JsDocToken unreadToken = NO_UNREAD_TOKEN;
-  private void restoreLookAhead(JsDocToken token) {
-    unreadToken = token;
-  }
-  private boolean match(JsDocToken token) {
-    unreadToken = next();
-    return unreadToken == token;
-  }
-  private boolean match(JsDocToken token1, JsDocToken token2) {
-    unreadToken = next();
-    return unreadToken == token1 || unreadToken == token2;
-  }
-  private JsDocToken next() {
-    if (unreadToken == NO_UNREAD_TOKEN) {
-      return stream.getJsDocToken();
-    } else {
-      return current();
-    }
-  }
-  private JsDocToken current() {
-    JsDocToken t = unreadToken;
-    unreadToken = NO_UNREAD_TOKEN;
-    return t;
-  }
-  private void skipEOLs() {
-    while (matchJsDocToken.EOL) {
-      next();
-      if (matchJsDocToken.STAR) {
-        next();
-      }
-    }
-  }
-  private String getRemainingJSDocLine() {
-    String result = stream.getRemainingJSDocLine();
-    return result;
-  }
-  private boolean hasParsedFileOverviewDocInfo() {
-    return jsdocBuilder.isPopulatedWithFileOverview();
-  }
-  boolean hasParsedJSDocInfo() {
-    return jsdocBuilder.isPopulated();
-  }
-  JSDocInfo retrieveAndResetParsedJSDocInfo() {
-    return jsdocBuilder.buildassociatedNode;
-  }
-  JSDocInfo getFileOverviewJSDocInfo() {
-    return fileOverviewJSDocInfo;
-  }
-  private boolean lookAheadForTypeAnnotation() {
-    boolean matchedLc = false;
-    int c;
-    while true {
-      c = stream.getChar();
-      if (c == ' ') {
-        continue;
-      } else if (c == '{') {
-        matchedLc = true;
-        break;
-      } else {
-        break;
-      }
-    }
-    stream.ungetCharc;
-    return matchedLc;
-  }
-}
\ No newline at end of file
