diff -rwu ORIGINAL_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java MODIFIED_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
--- ORIGINAL_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
+++ MODIFIED_PATH/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
@@ -57,6 +57,8 @@
     double[] diag = new double[cols];
     double[] oldX = new double[cols];
     double[] oldRes = new double[rows];
+    double[] oldObj = new double[rows];
+    double[] qtf = new double[rows];
     double[] work1 = new double[cols];
     double[] work2 = new double[cols];
     double[] work3 = new double[cols];
@@ -65,11 +67,14 @@
     boolean firstIteration = true;
     VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
     while true {
+      for (int i = 0; i < rows; i++) {
+        qtf[i] = residuals[i];
+      }
       incrementIterationsCounter();
       VectorialPointValuePair previous = current;
       updateJacobian();
       qrDecomposition();
-      qTyresiduals;
+      qTyqtf;
       for (int k = 0; k < solvedCols; ++k) {
         int pk = permutation[k];
         jacobian[k][pk] = diagR[pk];
@@ -96,13 +101,15 @@
           if (s != 0) {
             double sum = 0;
             for (int i = 0; i <= j; ++i) {
-              sum += jacobian[i][pj] * residuals[i];
+              sum += jacobian[i][pj] * qtf[i];
             }
             maxCosine = Math.max(maxCosine, Math.abssum / (s * cost));
           }
         }
       }
       if (maxCosine <= orthoTolerance) {
+        updateResidualsAndCost();
+        current = new VectorialPointValuePair(point, objective);
         return current;
       }
       for (int j = 0; j < cols; ++j) {
@@ -117,7 +124,10 @@
         double[] tmpVec = residuals;
         residuals = oldRes;
         oldRes = tmpVec;
-        determineLMParameter(oldRes, delta, diag, work1, work2, work3);
+        tmpVec = objective;
+        objective = oldObj;
+        oldObj = tmpVec;
+        determineLMParameter(qtf, delta, diag, work1, work2, work3);
         double lmNorm = 0;
         for (int j = 0; j < solvedCols; ++j) {
           int pj = permutation[j];
@@ -131,7 +141,6 @@
           delta = Math.min(delta, lmNorm);
         }
         updateResidualsAndCost();
-        current = new VectorialPointValuePair(point, objective);
         double actRed = -1.0;
         if (0.1 * cost < previousCost) {
           double r = cost / previousCost;
@@ -174,6 +183,12 @@
             xNorm += xK * xK;
           }
           xNorm = Math.sqrtxNorm;
+          current = new VectorialPointValuePair(point, objective);
+          if (checker != null) {
+            if (checker.converged(getIterations(), previous, current)) {
+              return current;
+            }
+          }
         } else {
           cost = previousCost;
           for (int j = 0; j < solvedCols; ++j) {
@@ -183,6 +198,9 @@
           tmpVec = residuals;
           residuals = oldRes;
           oldRes = tmpVec;
+          tmpVec = objective;
+          objective = oldObj;
+          oldObj = tmpVec;
         }
         if (checker == null) {
           if (((Math.absactRed <= costRelativeTolerance)
@@ -191,10 +209,6 @@
               || (delta <= parRelativeTolerance * xNorm)) {
             return current;
           }
-        } else {
-          if (checker.converged(getIterations(), previous, current)) {
-            return current;
-          }
         }
         if ((Math.absactRed <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
           throw new OptimizationException(
