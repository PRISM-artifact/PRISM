diff -rwu ORIGINAL_PATH/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java MODIFIED_PATH/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
--- ORIGINAL_PATH/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
+++ MODIFIED_PATH/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
@@ -56,22 +56,25 @@
     if (cachedU == null) {
       final int p = singularValues.length;
       if (m >= n) {
-        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
         final double[][] eData = e.getData();
         final double[][] wData = new double[m][p];
         double[] ei1 = eData[0];
-        for (int i = 0; i < p - 1; ++i) {
+        for (int i = 0; i < p; ++i) {
           final double mi = mainBidiagonal[i];
           final double[] ei0 = ei1;
           final double[] wi = wData[i];
+          if (i < n - 1) {
           ei1 = eData[i + 1];
           final double si = secondaryBidiagonal[i];
           for (int j = 0; j < p; ++j) {
             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
           }
-        }
+          } else {
         for (int j = 0; j < p; ++j) {
-          wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+              wi[j] = mi * ei0[j] / singularValues[j];
+            }
+          }
         }
         for (int i = p; i < m; ++i) {
           wData[i] = new double[p];
@@ -106,22 +109,25 @@
         final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
         cachedV = transformer.getV().multiplye;
       } else {
-        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
+        final RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
         final double[][] eData = e.getData();
         final double[][] wData = new double[n][p];
         double[] ei1 = eData[0];
-        for (int i = 0; i < p - 1; ++i) {
+        for (int i = 0; i < p; ++i) {
           final double mi = mainBidiagonal[i];
           final double[] ei0 = ei1;
           final double[] wi = wData[i];
+          if (i < m - 1) {
           ei1 = eData[i + 1];
           final double si = secondaryBidiagonal[i];
           for (int j = 0; j < p; ++j) {
             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
           }
-        }
+          } else {
         for (int j = 0; j < p; ++j) {
-          wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
+              wi[j] = mi * ei0[j] / singularValues[j];
+            }
+          }
         }
         for (int i = p; i < n; ++i) {
           wData[i] = new double[p];
